-- AULA LINGUAGEM SQL - MATUTINO
-- PROF. FABIANO PASSOS
-- MEU PRIMEIRO COMENTÁRIO EM LINHA

-- INICIANDO E FINALIZANDO TRANSAÇÕES
BEGIN TRANSACTION

USE PEDIDOS
SELECT * FROM TB_EMPREGADO
UPDATE TB_EMPREGADO SET PREMIO_MENSAL = PREMIO_MENSAL - 1000

--CONFIRMAR A TRANSAÇÃO
COMMIT

-- DEU ERRO! E VOU CANCELAR A TRANSAÇÃO!
ROLLBACK

-- HOT KEY: CTRL + R (APARECE E DESAPARECE A ABA DE RETORNO DA CONSULTA)

-- CRIANDO O MEU PRIMEIRO BANCO DE DADOS
-- UTILIZANDO: TRANSACT SQL OU T-SQL
CREATE DATABASE BD_ADS_BANCO

-- COLOCANDO O MEU BANCO DE DADOS EM USO
USE BD_ADS_BANCO

-- DELETAR O BANCO DE DADOS
DROP DATABASE BD_ADS_BANCO

-- CRIANDO TABELAS

-- Simple CREATE TABLE Syntax (common if not using options)
CREATE TABLE 
    { database_name.schema_name.table_name | schema_name.table_name | table_name }
    ( { <column_definition> } [ ,...n ] ) -- []: ALGO QUE É OPCIONAL
[ ; ]

CREATE TABLE <NOME_TABELA>			-- NOME DA TABELA QUE EU VOU FORNECER 
(	
	<NOME_COLUNA>	<TIPO_DE_DADO>	-- NOME E TIPO DE DADO, EU TBM IREI ESCREVER
) 
-- EXEMPLO: CRIAR UMA ENTIDADE (TABELA) COM SEUS RESPECTIVOS ATRIBUTOS (CAMPOS)
-- TABELA: TB_FUNCIONARIO
-- CAMPOS: CPF (NUMERICO), NOME (ALFANUMERICO), TELEFONE (NUMERICO), SALARIO (DINHEIRO)
-- PRECISO ME ATENTAR A PARTIR DE AGORA AO FORMATO DOS CAMPOS
CREATE TABLE TB_FUNCIONARIO
(
	CPF			INT,	  -- PRIMEIRO TIPO DE DADO QUE IREI APRENDER: INT OU INTEGER
	NOME		CHAR(20), -- SEGUNDO TIPO DE DADO QUE IREI APRENDER: CHAR(TAM_CAMPO)
	TELEFONE	INT,
	SALARIO		MONEY	  -- TERCEIRO TIPO DE DADO QUE IREI APRENDER: MONEY ($$$)	
)

-- EXEMPLO ABAIXO DE COMO FUNCIONA O TAMANHO DO CAMPO
12345678901234567890
FABIANO ROMEU HENRY PASSOS

-- EXERCICIOS:
/*
[COMENTÁRIO EM BLOCO]
TUDO QUE EU COLOCAR DENTRO DESTE BLOCO SERVIRÁ PARA COMENTAR MEU CÓDIGO

1. CRIAR UM BANCO DE DADOS, CHAMADO DB_DETRAN
2. COLOCAR O BANCO DE DADOS EM USO
3. CRIAR AS SEGUINTES ENTIDADES (TABELAS) DENTRO DELE
	A. TB_VEICULOS: RENAVAM (NUMÉRICO), MARCA (ALFA), MODELO (ALFA), ANO (NUMÉRICO)
	B. TB_MULTAS: RENAVAM (NUMÉRICO), COD_MULTA (ALFA), VALOR (DINHEIRO)
*/
CREATE DATABASE DB_DETRAN			-- 1. OK
USE DB_DETRAN						-- 2. OK
USE BD_ADS_BANCO

-- A. TB_VEICULOS: RENAVAM (NUMÉRICO), MARCA (ALFA), MODELO (ALFA), ANO (NUMÉRICO)
CREATE TABLE TB_VEICULOS
(
	RENAVAM		INT			,
	MARCA		CHAR(20)	,
	MODELO		CHAR(30)	,
	ANO			INT
)

-- B. TB_MULTAS: RENAVAM (NUMÉRICO), COD_MULTA (ALFA), VALOR (DINHEIRO)
CREATE TABLE TB_MULTAS
(
	RENAVAM		INT			,
	COD_MULTA	CHAR(08)	,
	VALOR		MONEY
)

-- DELETANDO TABELAS (NESTE CASO, SE CRIEI INDEVIDAMENTE)
DROP TABLE TB_MULTAS
DROP TABLE TB_VEICULOS


-- AULA 02: CRIAÇÃO DE TABELAS E CONSTRAINTS (RESTRIÇÕES OU CONFIGURAÇÕES)

-- CRIANDO UM DATABASE PARA QUEM NÃO TEM
-- OU APENAS ENTRANDO NO DATABASE PARA QUEM JÁ O POSSUI...
USE MASTER
DROP DATABASE BD_ADS_BANCO

CREATE DATABASE BD_ADS_BANCO

-- COLOCANDO EM USO...
USE BD_ADS_BANCO

-- CRIANDO UMA TABELA SEM CONFIGURAÇÃO:
CREATE TABLE TB_ALUNO
(
	CPF			BIGINT			,
	NOME		VARCHAR(30)
)

-- APAGANDO A TABELA INTEIRA
DROP TABLE TB_ALUNO

-- INSERINDO DADOS EM TABELAS (INSERT SIMPLES)
-- TUDO QUE ESTÁ ENTRE COLCHETES [] É OPCIONAL
INSERT  <object>		-- EM QUAL TABELA VOU FAZER A INSERÇÃO 
VALUES ( [ ,...n ] )	-- COM QUAIS VALORES EU INSIRO

-- INSERT MAIS SIMPLES POSSÍVEL
INSERT TB_ALUNO
VALUES
( 31790012060 , 'JOÃO' )
-- SEGUNDO INSERT MAIS SIMPLES POSSÍVEL
INSERT TB_ALUNO
( CPF , NOME )
VALUES
( 31790012060 , '' )

-- CONSULTANDO OS VALORES INSERIDOS
SELECT * FROM TB_ALUNO

-- NULL E NOT NULL
-- EXEMPLO: CRIAR UMA TABELA DE PROFESSORES, CONTENDO NOME E CPF, SENDO QUE CPF NÃO PODE SER NULO
CREATE TABLE TB_PROFESSOR
(
		CPF			BIGINT			NOT NULL
	,	NOME		VARCHAR(30)		NULL
)
-- INSERINDO DADOS NA TABELA DE PROFESSORES E TESTANDO SE ACEITA VALORES NULOS
INSERT TB_PROFESSOR
( CPF , NOME )
VALUES
( 100 , 'TAKAI' )
INSERT TB_PROFESSOR ( CPF ) VALUES ( 200 ) -- FUNCIONA POIS O CPF ESTÁ PREENCHIDO
INSERT TB_PROFESSOR ( NOME ) VALUES ( 'LÚCIO' ) -- NÃO FUNCIONA POIS O CPF NÃO PERMITE NULOS
SELECT * FROM TB_PROFESSOR

-- IDENTITY: AUTO NUMERAÇÃO NAS TABELAS SQL
-- EXEMPLO: CRIAR UMA TABELA DE DISCIPLINAS QUE VAI CONTER OS NOMES DAS DISCIPLINAS E UM CAMPO AUTO INCREMENTAL COM O CÓDIGO DELAS
CREATE TABLE TB_DISCIPLINAS
(
		ID_DISCIPLINA			INT				IDENTITY
	,	NOME_DISCIPLINA			VARCHAR(20)
)

-- INSERINDO MAIS DE UMA LINHA DE CADA VEZ
INSERT TB_DISCIPLINAS
( NOME_DISCIPLINA )
VALUES

( 'FUNDAMENTOS' ),
( 'LINGUAGEM PROG' ),
( 'ARQUITETURA' ),
( 'EMPREENDEDORISMO' )

SELECT * FROM TB_DISCIPLINAS

-- EXERCICIO:
-- CRIAR TABELA DE SALAS (DE UMA FACULDADE), CONTENDO NOME_SALA (A201, A202), DATA_DISPONIVEL (DATE), E UM CAMPO DE AUTO NUMERAÇÃO COM 
-- O ID_SALA
CREATE TABLE TB_SALAS
(
			NOME_SALA				CHAR(04)
		,	DATA_DISPONIVEL			DATE
		,	ID_SALA					INT		IDENTITY
)

INSERT TB_SALAS
( NOME_SALA , DATA_DISPONIVEL )
VALUES 
( 'A201' , '2014-01-01' ),
( 'B201' , '2014-12-31' ),
( 'C201' , '2014-06-10' ),
( 'D201' , '2014-07-01' )

SELECT * FROM TB_SALAS

-- APAGANDO A TABELA
DELETE FROM TB_SALAS

-- CRIANDO ESTRUTURAS RELACIONAIS UTILIZANDO PRIMARY E FOREIGN KEY
-- PRIMARY KEY
-- 1. NÃO PERMITE DUPLICIDADE (OK)
-- 2. ME DÁ UMA MELHOR PERFORMANCE DE BUSCA (CRIA UM ÍNDICE)
-- 3. ABRE UMA POSSIBILIDADE DE RELACIONAMENTO
CREATE TABLE TB_EMPREGADOS
(
		CPF				BIGINT		
	,	NOME			VARCHAR(30)
	,   SALARIO			MONEY
	,   ID_CARGO		INT

	CONSTRAINT PK_TB_EMPREGADOS_CPF		PRIMARY KEY (CPF),
	
	CONSTRAINT FK_EMPREGADOS_ID_CARGO	FOREIGN KEY (ID_CARGO)
	REFERENCES TB_CARGO(ID_CARGO)
)
DROP TABLE TB_EMPREGADOS

CREATE TABLE TB_CARGO
(
		ID_CARGO		INT
	,	NOME_CARGO		VARCHAR(30)

	CONSTRAINT PK_TB_CARGO_ID_CARGO		PRIMARY KEY (ID_CARGO)
)
DROP TABLE TB_CARGO
-- POPULANDO AS TABELAS
INSERT TB_EMPREGADOS
( CPF , NOME , SALARIO , ID_CARGO )
VALUES
( 100 , 'ANA'		, 1000 , 1 ), ( 200 , 'BEATRIZ'	, 2000 , 1 ), ( 300 , 'CAROL'		, 3000 , 3 )

INSERT TB_EMPREGADOS ( CPF , NOME , SALARIO , ID_CARGO )  VALUES ( 400 , 'DANIELLA'		, 3000 , 4 )

INSERT INTO TB_CARGO
( ID_CARGO , NOME_CARGO )
VALUES
( 1 , 'GERENTE COMERCIAL' ), ( 2 , 'DBA' ), ( 3 , 'ANALISTA SUPORTE' )

INSERT INTO TB_CARGO ( ID_CARGO , NOME_CARGO ) VALUES ( 4 , 'ANALISTA SISTEMAS' )

SELECT * FROM TB_EMPREGADOS
SELECT * FROM TB_CARGO

-- CRIAR BANCO DE DADOS DB_EMPRESA
-- COLOCAR BANCO DE DADOS EM USO
-- CRIAR TABELAS DE FUNCIONARIOS E DEPENDENTES

-- TB_FUNCIONARIOS: CPF, NOME, SALARIO (CPF E NOME NÃO PODEM SER NULOS E CPF DEVE SER CHAVE PRIMÁRIA).
-- OBS.: DEVE EXISTIR UM CAMPO DE AUTO INCREMENTO CHAMADO ID_FUNCIONARIO

-- TB_DEPENDENTES: CPF, NOME, CPF_FUNCIONARIO_RESPONSAVEL (CPF E NOME NÃO PODEM SER NULOS E CPF DEVE SER CHAVE PRIMÁRIA).
-- OBS.: O CAMPO CPF_FUNCIONARIO_RESPONSAVEL DEVE TER RELACIONAMENTO COM O CAMPO DE CPF DA TABELA DE FUNCIONARIOS
CREATE DATABASE DB_EMPRESA_ADS_BD
USE DB_EMPRESA_ADS_BD

CREATE TABLE TB_FUNCIONARIOS
(
		ID_FUNCIONARIO				INT			IDENTITY ( 255 , -1 ) -- COMEÇA DO 255 E RETIRA 1 A CADA INSERÇÃO
	,	CPF							BIGINT		NOT NULL
	,	NOME						VARCHAR(50)	NOT NULL
	,	SALARIO						MONEY

	CONSTRAINT	PK_TB_FUNCIONARIOS_CPF			PRIMARY KEY (CPF)
)

INSERT INTO TB_FUNCIONARIOS
(	CPF		,	NOME		,	SALARIO )
VALUES
( 111		,	'FABIANO'	, 1000 ),
( 222		,	'ISABELLA'	, 1000 ),
( 333		,	'MARIA'		, 1000 )

INSERT INTO TB_FUNCIONARIOS
(	CPF		,	NOME		,	SALARIO )
VALUES
( 555		,	'MARIO'	, 1000 )

-- TESTANDO O ESTOURO DE VARIÁVEL INT VERSUS BIGINT
INSERT INTO TB_FUNCIONARIOS
(	CPF		,	NOME		,	SALARIO )
VALUES
( 31791000061		,	'MARIO'	, 1000.50 )

-- MAIOR VALOR POSSÍVEL PARA UM INT:
--  2.147.483.647
-- 31.790.000.061

-- NOTAÇÃO SQL É AMERICANA:		DECIMAL POINT IS POINT
-- OBS.: NOTAÇÃO BRASILEIRA:	DECIMAL POINT IS COMMA (VIRGULA)
-- R$ 1000,50
-- R$ 1000.50


CREATE TABLE TB_DEPENDENTES
(
		CPF							BIGINT		NOT NULL
	,	NOME						VARCHAR(50)	NOT NULL
	,	CPF_FUNCIONARIO_RESPONSAVEL	BIGINT

	CONSTRAINT	PK_TB_DEPENDENTES_CPF			PRIMARY KEY (CPF) ,
	CONSTRAINT	FK_TB_DEPENDENTES_CPF_RESP		FOREIGN KEY (CPF_FUNCIONARIO_RESPONSAVEL)
	REFERENCES	TB_FUNCIONARIOS (CPF)
)

INSERT INTO TB_DEPENDENTES
(	CPF			,		NOME			,		CPF_FUNCIONARIO_RESPONSAVEL )
VALUES
(   10000		,		'NATÁLIA'		,		111 )

INSERT INTO TB_DEPENDENTES
(	CPF			,		NOME			,		CPF_FUNCIONARIO_RESPONSAVEL )
VALUES
(   20000		,		'DOUGLAS'		,		555 )


SELECT * FROM TB_FUNCIONARIOS
SELECT * FROM TB_DEPENDENTES

USE DB_EMPRESA_ADS_BD

DROP TABLE TB_DEPENDENTES
DROP TABLE TB_FUNCIONARIOS

-- UNIQUE: NÃO PERMITE VALORES DUPLICADOS, PORÉM, NÃO PRECISA CRIAR UMA CHAVE PRIMÁRIA PARA ISSO
CREATE TABLE TB_PROFESSORES
(
		CPF				BIGINT
	,	RG				BIGINT
	,	NOME			VARCHAR(50)
	
	CONSTRAINT	UQ_TB_PROFESSORES_RG		UNIQUE (RG)
)
INSERT INTO TB_PROFESSORES
( CPF , RG , NOME )
VALUES
( 2 , 2 , 'JOÃO')

SELECT * FROM TB_PROFESSORES

-- CHECK: VERIFICA DETERMINADA CONDIÇÃO PARA PERMITIR OU NÃO A INSERÇÃO DE UM VALOR NO CAMPO
-- EXEMPLO: NÃO PERMITIR CADASTRAR NENHUM PRODUTO ABAIXO DE R$ 2.00
CREATE TABLE TB_PRODUTOS
(
		ID				INT				IDENTITY 
	,	NOME			VARCHAR(30)
	,	VALOR			DECIMAL(6 , 2)  -- 9999,99   (POSSUI 6 POSIÇÕES, DAS QUAIS DUAS SÃO APÓS A VÍRGULA)
										-- 999999,99 (ERRO COMUM!)
	
	CONSTRAINT		CK_TB_PRODUTOS_VALOR			CHECK (VALOR >= 2) -- CONDIÇÃO QUE EU QUERO MANTER NA TABELA
)
INSERT TB_PRODUTOS
( NOME , VALOR )
VALUES
( 'CANETA' , 2.99)

-- EXERCICIO DESAFIO: 
-- CRIAR UMA TABELA DE CADASTRO QUE CONTENHA: NOME, CPF E DATA_CAD
-- NÃO PERMITIR NENHUM CADASTRO DE MENORES DO QUE 18 ANOS (CONTAR A PARTIR DA DATA DE HOJE)
-- A PERGUNTA É... QUE DIA NASCEU, QUEM FAZ 18 ANOS HOJE? 10-SET-2002 OU EM SQL 2002-09-10 (AAAA-MM-DD)
CREATE TABLE TB_CADASTRO
(
		NOME			VARCHAR(30)
	,	CPF				BIGINT
	,	DATA_CAD		DATE
	
	CONSTRAINT	CK_TB_CADASTRO_DATA_CAD			CHECK (DATA_CAD <= '2002-09-10' )
)
INSERT TB_CADASTRO
( NOME , CPF , DATA_CAD )
VALUES
( 'ANTONIO' , 317 , '2002-09-11' )


-- CONSTRAINTS (RESTRIÇÕES) OU CONFIGURAÇÕES
-- 1. NULL E NULL NOT
-- 2. IDENTITY
-- 3. PRIMARY KEY
-- 4. FOREIGN KEY
-- 5. UNIQUE
-- 6. CHECK


-- AC01: DDL (DATA DEFINITION LANGUAGE) - CREATE TABLE + CONSTRAINTS
CREATE DATABASE CONCESSIONARIA
GO
USE CONCESSIONARIA
GO

CREATE TABLE TB_ANO
(
		ID_ANO				SMALLINT	IDENTITY		-- 32.767
	,	ANO					SMALLINT

		CONSTRAINT	PK_TB_ANO_ID_ANO			PRIMARY KEY (ID_ANO)
	,	CONSTRAINT	CK_TB_ANO_ID_ANO			CHECK (ID_ANO <= 200)
)

INSERT TB_ANO
( ANO )
VALUES
( 2000 ),
( 2001 ),
( 2002 ),
( 2003 ),
( 2004 )

CREATE TABLE TB_MES
(
		ID_MES				SMALLINT	IDENTITY ( 15 , 3 )  -- E O FATO DE NÃO PODER ULTRAPASSAR 200 REGISTROS
	,	MES					SMALLINT

		CONSTRAINT	PK_TB_MES_ID_MES			PRIMARY KEY (ID_MES)
	,	CONSTRAINT  CK_TB_MES_ID_MES			CHECK (ID_MES <= 612) 
)

-- 1º REGISTRO: 15
-- 199 * 3 = 597
-- 597 + 15 = 612

INSERT TB_MES
( MES )
VALUES
( 01 ),
( 02 ),
( 03 ),
( 04 ),
( 05 )

CREATE TABLE TB_MODELO
(
		ID_MODELO		SMALLINT	IDENTITY
	,	DESCRICAO		VARCHAR(50)	NOT NULL

		CONSTRAINT	PK_TB_MODELO_ID_MODELO		PRIMARY KEY (ID_MODELO)
	,	CONSTRAINT	CK_TB_MODELO_ID_MODELO		CHECK (ID_MODELO <= 200)
)

INSERT TB_MODELO
( DESCRICAO )
VALUES
( 'GOL' ),
( 'PALIO' ),
( 'KA' ),
( 'FIESTA' ),
( 'RENEGADE' )

CREATE TABLE TB_FABRICANTE
(
		ID_FABRICANTE	SMALLINT		IDENTITY
	,	NOME			VARCHAR(50)		NOT NULL
	,	CIDADE			VARCHAR(50)		NOT NULL
	,	ENDERECO		VARCHAR(100)	
	,	UF				CHAR(02)		
	,	TELEFONE		VARCHAR(20)
	,	CONTATO			VARCHAR(50)		NOT NULL

		CONSTRAINT	PK_TB_FABRICANTE_ID_FABRICANTE		PRIMARY KEY (ID_FABRICANTE)
	,	CONSTRAINT	CK_TB_FABRICANTE_ID_FABRICANTE		CHECK (ID_FABRICANTE <= 200)
)

INSERT TB_FABRICANTE
( NOME , CIDADE , ENDERECO , UF , TELEFONE , CONTATO )
VALUES
( 'VOLKSWAGEN' , 'SÃO BERNARDO' , 'RODOVIA ANCHIETA S/N' , 'SP' , '2000-9999' , 'VOLWSWAGEN@VOLWSWAGEN.COM' ),
( 'FORD' , 'SÃO BERNARDO' , 'AV. TABOÃO' , 'SP' , '2000-9999' , 'FORD@FORD.COM' )

CREATE TABLE TB_VEICULO
(
		ID_VEICULO				SMALLINT				IDENTITY
	,	DESCRICAO				VARCHAR(50)				NOT NULL
	,	VALOR					DECIMAL ( 8 , 2 )		NOT NULL -- CHEGARÁ A CASA DOS R$ 200.000,00. COM ESSA DEFINIÇÃO DE CAMPO: R$ 999.999,99
	,	ID_MODELO				SMALLINT			
	,	ID_FABRICANTE			SMALLINT
	,	ID_ANO_FABRICACAO		SMALLINT
	,	DATA_COMPRA				DATE					NOT NULL

		CONSTRAINT	PK_TB_VEICULO_ID_VEICULO			PRIMARY KEY (ID_VEICULO)
	,   CONSTRAINT  CK_TB_VEICULO_ID_VEICULO			CHECK (ID_VEICULO <= 10000)
	,	CONSTRAINT  FK_TB_VEICULO_ID_MODELO				FOREIGN KEY (ID_MODELO)				REFERENCES	TB_MODELO(ID_MODELO)
	,	CONSTRAINT  FK_TB_VEICULO_ID_FABRICANTE			FOREIGN KEY (ID_FABRICANTE)			REFERENCES  TB_FABRICANTE(ID_FABRICANTE)
	,	CONSTRAINT  FK_TB_VEICULO_ID_ANO_FABRICACAO		FOREIGN KEY (ID_ANO_FABRICACAO)		REFERENCES  TB_ANO(ID_ANO)
)

INSERT TB_VEICULO
( DESCRICAO	, VALOR , ID_MODELO , ID_FABRICANTE , ID_ANO_FABRICACAO , DATA_COMPRA )
VALUES
( 'RENEGADE' , 250000.99 , 5 , 1 , 1 , '2020-09-15' )

INSERT TB_VEICULO
( DESCRICAO	, VALOR , ID_MODELO , ID_FABRICANTE , ID_ANO_FABRICACAO , DATA_COMPRA )
VALUES
( 'KA' , 40000.50 , 3 , 2 , 2 , '2005-01-01' )

CREATE TABLE TB_VENDAS_ANUAIS
(
		ID_VENDAS			SMALLINT		IDENTITY
	,	QTD					SMALLINT		NOT NULL
	,	ID_VEICULO			SMALLINT
	,	ID_ANO_DA_VENDA		SMALLINT
	,	ID_MES_DA_VENDA		SMALLINT

		CONSTRAINT	PK_TB_VENDAS_ANUAIS_ID_VENDAS			PRIMARY KEY(ID_VENDAS)
	,	CONSTRAINT	CK_TB_VENDAS_ANUAIS_ID_VENDAS			CHECK(ID_VENDAS <= 10000)
	,	CONSTRAINT	CK_TB_VENDAS_ANUAIS_QTD_MIN				CHECK(QTD >= 1)
	,	CONSTRAINT	CK_TB_VENDAS_ANUAIS_QTD_MAX				CHECK(QTD <= 5000)

	,	CONSTRAINT	FK_TB_VENDAS_ANUAIS_ID_VEICULO			FOREIGN KEY(ID_VEICULO) 		REFERENCES  TB_VEICULO(ID_VEICULO)
	,	CONSTRAINT	FK_TB_VENDAS_ANUAIS_ID_ANO_DA_VENDA		FOREIGN KEY(ID_ANO_DA_VENDA)	REFERENCES  TB_ANO(ID_ANO)
	,	CONSTRAINT	FK_TB_VENDAS_ANUAIS_ID_MES_DA_VENDA		FOREIGN KEY(ID_MES_DA_VENDA)	REFERENCES  TB_MES(ID_MES)
)

INSERT TB_VENDAS_ANUAIS
( QTD , ID_VEICULO , ID_ANO_DA_VENDA , ID_MES_DA_VENDA )
VALUES
( 1000 , 1 , 1 , 15 )

INSERT TB_VENDAS_ANUAIS
( QTD , ID_VEICULO , ID_ANO_DA_VENDA , ID_MES_DA_VENDA )
VALUES
( 2000 , 1 , 1 , 18 )


SELECT * FROM TB_ANO
SELECT * FROM TB_MES
SELECT * FROM TB_MODELO
SELECT * FROM TB_FABRICANTE
SELECT * FROM TB_VEICULO
SELECT * FROM TB_VENDAS_ANUAIS

-- IMPORTAÇÃO DE BANCO DE DADOS EXISTENTE: DATABASE PEDIDOS
USE PEDIDOS

SELECT * FROM TB_EMPREGADO

-- EXERCICIO PARA SE FAMILIARIZAR COM O DATABASE PEDIDOS: 
-- 1. FAZER SELECT EM ALGUMAS TABELAS, PARA CONHECER MEU MODELO (3 OU 4 TABELAS)
-- 2. CRIAR UM DRIGRAMA DE BANCO DE DADOS COM O DATABASE PEDIDOS (ESTUDEM A ESTRUTURA)
-- 3. DROP DATABASE PEDIDOS - COPIAR OS ARQUIVOS NOVAMENTE - ANEXAR NOVAMENTE...
USE MASTER

DROP DATABASE PEDIDOS

CREATE DATABASE PEDIDOS

CREATE TABLE TB_EMPREGADO

USE PEDIDOS
USE MASTER

-- SINTAXE COMPLETA DO SELECT DE ACORDO COM O DOCS DA MICROSOFT ESTÁ ABAIXO:
/*
SELECT	[ ALL | DISTINCT ]   
		[TOP ( expression ) [PERCENT] [ WITH TIES ] ]   
		< select_list >		
[ INTO new_table ]   
[ FROM { <table_source> } [ ,...n ] ]   
[ WHERE <search_condition> ]   
[ <GROUP BY> ]   
[ HAVING < search_condition > ]
[ ORDER BY [ ASC | DESC ] ]
*/

-- SELECIONANDO CAMPOS, E TABELAS...
SELECT * FROM TB_EMPREGADO

SELECT	NOME, SALARIO, DATA_ADMISSAO
FROM	TB_EMPREGADO

SELECT GETDATE()
SELECT 'FABIANO PASSOS'

SELECT *
FROM TB_EMPREGADO, TB_CARGO, TB_DEPARTAMENTO, TB_PEDIDO

SELECT * FROM TB_CARGO

-- ORDER BY: ORDENAR O MEU RETORNO DE CONSULTA
-- EXEMPLO: TRAZER O RETORNO EM ORDEM ALFABETICA

SELECT		NOME, SALARIO, DATA_ADMISSAO
FROM		TB_EMPREGADO
ORDER BY	NOME -- DEFAULT É ASC

SELECT		NOME, SALARIO, DATA_ADMISSAO
FROM		TB_EMPREGADO
ORDER BY	NOME ASC

SELECT		NOME, SALARIO, DATA_ADMISSAO
FROM		TB_EMPREGADO
ORDER BY	NOME DESC

-- EXERCICIO:	TRAZER DA TABELA DE FUNCIONÁRIOS, O NOME, O PREMIO_MENSAL, A DATA DE ADMISSÃO, 
--				ONDENANDO PELOS FUNCIONÁRIOS MAIS NOVOS PRIMEIRO...
SELECT * FROM TB_EMPREGADO

SELECT		NOME, PREMIO_MENSAL, DATA_ADMISSAO
FROM		TB_EMPREGADO
ORDER BY	DATA_ADMISSAO DESC

-- CRIAR ALIAS E CAMPOS QUE NÃO EXISTEM NA TABELA
-- ALIAS: NOVO NOME PARA UMA COLUNA JÁ EXISTENTE OU NOME PARA UMA COLUNA NOVA

-- PEDIDO:		TRAZER DA TABELA DE FUNCIONÁRIOS, O NOME, O PREMIO_MENSAL, A DATA DE ADMISSÃO, 
--				ONDENANDO PELOS FUNCIONÁRIOS MAIS NOVOS PRIMEIRO. TRAZER TAMBÉM A DATA DE EXTRAÇÃO DESTE RELATÓRIO.
SELECT		NOME, PREMIO_MENSAL, DATA_ADMISSAO, GETDATE() AS DATA_DO_REPORT
FROM		TB_EMPREGADO
ORDER BY	DATA_ADMISSAO DESC

-- EXEMPLO DE CONSULTA COM ERRO, ALTERANDO O NOME DOS CAMPOS COM UM FALSO ALIAS
SELECT		NOME, SALARIO, PREMIO_MENSAL, COD_CARGO
FROM		TB_EMPREGADO


-- SELECT ALL | DISTINCT: ALL TRAZ TODOS OS VALORES, INCLUSIVE OS REPETIDOS. E O DISTINCT, TRAZ OS VALORES EXCLUSIVOS
SELECT	ALL COD_CARGO
FROM	TB_EMPREGADO

SELECT	DISTINCT COD_CARGO
FROM	TB_EMPREGADO

-- EXERCICIO: SELECIONAR QUAIS/QUANTOS  OS CLIENTES JÁ FIZERAM PEDIDO EM MINHA LOJA. ORDENAR O RESULTADO EM ORDEM DECRESCENTE.
SELECT  TOP 3 * FROM TB_PEDIDO

SELECT			DISTINCT CODCLI
FROM			TB_PEDIDO
ORDER BY		CODCLI DESC

-- [TOP ( expression ) [PERCENT] [ WITH TIES ] ]
-- RETORNA OS "N" PRIMEIROS REGISTROS DE UMA TABELA, OU, QUANDO UTILIZAMOS O PERCENT, OS "N" PRIMEIROS PORCENTO DE UMA TABELA
SELECT		TOP (10)
			NOME
		,	SALARIO
		,	PREMIO_MENSAL
FROM		TB_EMPREGADO

SELECT		TOP 10 PERCENT
			NOME
		,	SALARIO
		,	PREMIO_MENSAL
FROM		TB_EMPREGADO

-- EXERCICIO: TRAZER OS FUNCIONARIOS COM OS 10 MAIORES SALARIOS DA EMPRESA. RETORNO: NOME, SALARIO, SINDICALIZADO E DATA ATUAL 
-- DICA: TOP + ORDER BY (RANKING)
SELECT			TOP 10 WITH TIES
				NOME
			,	SALARIO
			,	SINDICALIZADO
			,	GETDATE()
FROM			TB_EMPREGADO
ORDER BY		SALARIO DESC

--1. TRAZER OS 20 ITENS MAIS BARATOS DA TABELA DE PRODUTO (DE ACORDO COM A COLUNA PRECO_VENDA)
--2. TRAZER OS 20 MAIORES SALARIOS DA EMPRESA (TABELA: TB_EMPREGADO)
--3. TRAZER OS 20 MAIORES PREMIOS DA EMPRESA (TABELA: TB_EMPREGADO)
SELECT * FROM TB_EMPREGADO
select * from tb_empregado
Select * From Tb_Empregado

-- SINTAXE COMPLETA DO SELECT DE ACORDO COM O DOCS DA MICROSOFT ESTÁ ABAIXO:
/*
SELECT	[ ALL | DISTINCT ]									-- OK
		[TOP ( expression ) [PERCENT] [ WITH TIES ] ]		-- OK
		< select_list >										-- OK
[ INTO new_table ]											-- JUNTO COM INSERT (DEPOIS...)
[ FROM { <table_source> } [ ,...n ] ]						-- OK
[ WHERE <search_condition> ]								-- HOJE!!!
[ <GROUP BY> ]												-- NAS PRÓXIMAS AULAS...
[ HAVING < search_condition > ]								-- NAS PRÓXIMAS AULAS...
[ ORDER BY [ ASC | DESC ] ]									-- OK
*/

USE PEDIDOS

-- WHERE: INSERINDO CONDIÇÕES PARA BUSCA DE INFORMAÇÕES
-- EXEMPLO: SELECIONAR APENAS O CODCLI = 5
SELECT		*
FROM		TB_CLIENTE
WHERE		CODCLI = 5

-- OPERADORES RELACIONAIS: = (IGUAL) ; <> (DIFERENTE) ; > (MAIOR) ; >= (MAIOR OU IGUAL) ; < (MENOR) ; <= (MENOR OU IGUAL)
-- MENOS COMUM: ! (NEGAÇÃO)... != (NÃO IGUAL) ; !> (NÃO MAIOR)...

-- EXEMPLO: SELECIONAR TODOS OS CLIENTES QUE POSSUAM ICMS MAIOR DO QUE 12
SELECT		*
FROM		TB_CLIENTE 
WHERE		ICMS > 12

-- EXERCICIOS:
-- 1. SELECIONAR OS CLIENTES DO ESTADO DE SP
SELECT		*
FROM		TB_CLIENTE
WHERE		ESTADO = 'SP'

-- 2. SELECIONAR OS EMPREGADOS QUE POSSUAM SALÁRIO MAIOR DO QUE 3000
SELECT		*
FROM		TB_EMPREGADO
WHERE		SALARIO > 3000

-- EXEMPLO: CONSULTANDO OS FUNCIONÁRIOS QUE NASCERAM APÓS 1990
SELECT		*
FROM		TB_EMPREGADO
WHERE		DATA_NASCIMENTO >= '2020-02-29' -- FORMATO DE DATA: 'AAAA-MM-DD'

-- OPERADORES LÓGICOS: AND (E: RESTRINGIR A MINHA BUSCA) ; OR (OR: AUMENTAR O MEU RETORNO, ACRESCENTAR CONDIÇÕES)

-- NECESSIDADE: CONSULTAR MAIS DE UMA CONDIÇÃO AO MESMO TEMPO
-- EXEMPLO: SELECIONAR TODOS OS EMPREGADOS QUE NASCERAM APÓS 1990 E QUE SEJAM SINDICALIZADOS

SELECT		*
FROM		TB_EMPREGADO
WHERE		DATA_NASCIMENTO >= '1990-01-01' -- FORMATO DE DATA: 'AAAA-MM-DD'
AND			SINDICALIZADO = 'S'	

-- EXEMPLO: RETORNAR OS FUNCIONÁRIOS DOS CARGOS MAIORES DO QUE 5 OU QUE POSSUAM SALARIO MAIOR DO QUE 2000
SELECT		*
FROM		TB_EMPREGADO
WHERE		COD_CARGO > 5		OR	SALARIO > 2000

-- EXERCICIOS: 
-- 1. SELECIONAR OS PRODUTOS QUE POSSUAM PRECO_CUSTO MAIOR DO QUE 2 E QUANTIDADE REAL MAIOR DO QUE 1000
SELECT		* 
FROM		TB_PRODUTO
WHERE		PRECO_CUSTO > 2			AND		QTD_REAL > 1000 
-- 23 LINHAS

-- 2. SELECIONAR OS FORNECEDORES QUE SEJAM DA CIDADE DE SAO PAULO OU DE ESTADO DIFERENTE DE SP
SELECT		* 
FROM		TB_FORNECEDOR
WHERE		CIDADE = 'SAO PAULO'	OR	ESTADO !='SP'
ORDER BY ESTADO

-- 3. SELECIONAR OS EMPREGADOS QUE POSSUAM SALARIO MENOR DO QUE O PREMIO_MENSAL OU QUE NÃO SEJAM SINDICALIZADOS
SELECT		* 
FROM		TB_EMPREGADO
WHERE		SALARIO < PREMIO_MENSAL	OR	SINDICALIZADO = 'N'

-- 4. SELECIONAR OS EMPREGADOS QUE POSSUAM SALARIO MENOR DO QUE 2000, TAMBÉM TRAZER OS QUE POSSUAM SALARIO MAIOR QUE 5000
SELECT		* 
FROM		TB_EMPREGADO
WHERE		SALARIO < 2000		OR		SALARIO > 5000
ORDER BY	SALARIO

-- CUIDADO QUANDO EU TENHO MISTURA DE AND COM OR, OU QUANDO TENHO MAIS DE UMA CONDIÇÃO ENVOLVENDO O MESMO CAMPO!!!


-- TRAZER UMA FAIXA DE VALORES, OU SEJA, OBSERVAR A PALAVRA CHAVE: ENTRE
-- RETORNAR TODOS OS FUNCIONÁRIOS QUE GANHEM ENTRE 1000 E 3000 (NÃO QUER DIZER QUE SEJA 1001 A 2999)
SELECT		*
FROM		TB_EMPREGADO
WHERE		SALARIO >= 1000			AND		SALARIO <= 3000

-- COMANDO PARA ESTES CASOS: BETWEEN
SELECT		*
FROM		TB_EMPREGADO
WHERE		SALARIO BETWEEN 1000 AND 3000

-- EXERCICIO:
-- 1. SELECIONAR OS EMPREGADOS NASCIDOS NA DÉCADA DE 90 OU OS FUNCIONÁRIOS QUE POSSUAM PREMIO_MENSAL MAIOR DO QUE 5000
-- OBS.: UTILIZAR AS DUAS FORMAS: COM WHERE + >= + <= ; E COM BETWEEN
SELECT		*
FROM		TB_EMPREGADO
WHERE		DATA_NASCIMENTO >= '1990-01-01' AND DATA_NASCIMENTO <= '1999-31-12'

-- CASO OCORRA O ERRO: A conversão de um tipo de dados varchar em um tipo de dados 
-- datetime resultou em um valor fora do intervalo.........

-- SOLUÇÃO: TESTAR COMO 'AAAA-DD-MM'

SELECT		*
FROM		TB_EMPREGADO
WHERE		DATA_NASCIMENTO BETWEEN '1990-01-01' AND '1999-31-12'

-- OPERADORES MATEMÁTICOS: + ; - ; / ; * ; % (RESTO DA DIVISÃO)
-- POSSO UTILIZÁ-LOS EM QUALQUER PARTE DO CÓDIGO: SELECT LIST, WHERE E OUTROS SEGMENTOS

-- EXEMPLO: SOMAR 500 REAIS NOS SALÁRIOS DOS EMPREGADOS DE CÓDIGO DO CARGO IGUAL A 14
SELECT		NOME, SALARIO, SALARIO + 500 AS NOVO_SALARIO
FROM		TB_EMPREGADO
WHERE		COD_CARGO = 14

-- EXEMPLO: MULTIPLICAR O PREMIO_MENSAL POR 2
SELECT		NOME, PREMIO_MENSAL, PREMIO_MENSAL * 2 AS DOBRO_PREMIO
FROM		TB_EMPREGADO

-- EXERCICIO:
-- 1. TRAZER A DESCRICAO DOS PRODUTOS, JUNTAMENTE COM O LUCRO (VENDA - CUSTO)
SELECT			DESCRICAO, PRECO_VENDA, PRECO_CUSTO, PRECO_VENDA - PRECO_CUSTO AS LUCRO
FROM			TB_PRODUTO

-- 2. SIMULACAO DOS PRODUTOS QUE POSSUAM COD DO TIPO IGUAL A 1 OU 3, CRIANDO UM CAMPO QUE REPRESENTE A MULTIPLICACAO
-- DO PRECO DE VENDA PELA QUANTIDADE MINIMA
SELECT			DESCRICAO, PRECO_VENDA, QTD_MINIMA, PRECO_VENDA * QTD_MINIMA AS SIMULACAO
FROM			TB_PRODUTO
WHERE			COD_TIPO = 1 OR COD_TIPO = 3

SELECT		*, DESCRICAO, PRECO_VENDA, QTD_MINIMA, PRECO_VENDA * QTD_MINIMA AS MULT
FROM		TB_PRODUTO
WHERE		COD_PRODUTO = '001' 
OR			COD_PRODUTO = '003'

-- 3. CALCULAR O DISSÍDIO DOS EMPREGADOS EM 8%. OU SEJA: CRIAR UMA COLUNA COM O SALARIO, ACRESCIDO DE 8% 
SELECT		NOME, 
			SALARIO,
			SALARIO * 0.08 AS OITO_POR_CENTO,
			SALARIO + (SALARIO * 0.08) AS SALARIO_NOVO
FROM		TB_EMPREGADO

SELECT		NOME, 
			SALARIO,
			SALARIO * 0.08 AS OITO_POR_CENTO,
			SALARIO + (SALARIO * 8 / 100) AS SALARIO_NOVO
FROM		TB_EMPREGADO

SELECT		NOME, 
			SALARIO,
			SALARIO * 1.08 AS SALARIO_NOVO
FROM		TB_EMPREGADO

-- CONSULTA DE CAMPOS ALFANUMÉRICOS
-- COMANDO LIKE: BUSCA POR APROXIMAÇÃO.
-- PARÂMETROS: % (CORINGA) ; [] (LISTA DE OPÇÕES SUBSTITUINDO UM CARACTERE) ; _ (SINALIZAÇÃO DE UM CARACTERE QUALQUER)

-- EXEMPLO: SELECIONAR QUAL FUNCIONÁRIO POSSUI OLAVO COMO PRIMEIRO NOME
SELECT		* 
FROM		TB_EMPREGADO
WHERE		NOME LIKE 'OLAVO%'

-- EXEMPLO: SELECIONAR OS NOMES QUE POSSUAM "MA" EM QUALQUER PARTE DO NOME
SELECT		* 
FROM		TB_EMPREGADO
WHERE		NOME LIKE '%MA%'

-- EXERCICIO: BUSCAR TODOS OS COLABORADORES DA FAMILIA "SILV"
SELECT		*
FROM		TB_EMPREGADO
WHERE		NOME LIKE '%SILV%'

-- EXERCICIO: SELECIONAR OS FUNCIONÁRIOS DA FAMILIA SOUZA OU SOUSA
SELECT		*
FROM		TB_EMPREGADO
WHERE		NOME LIKE '%SOUSA%' OR NOME LIKE '%SOUZA%'

-- OPÇÃO MENOS CERTA
SELECT		*
FROM		TB_EMPREGADO
WHERE		NOME LIKE '%SOU%A%'

-- PARÂMETRO []: LISTA DE OPÇÕES PARA UM CARACTERE
SELECT		*
FROM		TB_EMPREGADO
WHERE		NOME LIKE '%SOU[SZABCDE]A%'
                        SOU S       A = SOUSA
						SOU  Z      A = SOUZA
				        SOU   A     A = SOUAA
						SOU    B    A = SOUBA

-- PARÂMETRO _: SUBSTITUI UM CARACTERE
SELECT		*
FROM		TB_EMPREGADO
WHERE		NOME LIKE '%SOU_A%' [ABCDEFGHI.... TODAS OPÇÕES]

-- QUERO SABER TODOS OS FUNCIONÁRIOS QUE POSSUAM A COMBINACAO M+QUALQUERCOISA+R
SELECT		*
FROM		TB_EMPREGADO
WHERE		NOME LIKE '%M__R%'

-- EXERCICIO: SELECIONAR TODOS OS COLABORADORES QUE POSSUAM UMA VOGAL COMO SEGUNDA POSIÇÃO NO NOME
-- % ; [] ; _ (COMBINAR PARA FAZER O EXERCICIO)
SELECT		*
FROM		TB_EMPREGADO
WHERE		NOME LIKE '_[AEIOU]%'

-- SE PRECISAR TROCAR PARA TER UM NOME QUE CONTENHA UMA CONSOANTE NA SEGUNDA POSIÇÃO
SELECT		*
FROM		TB_EMPREGADO
WHERE		NOME NOT LIKE '_[AEIOU]%'

-- EXPLICAÇÃO SOBRE A AC02

-- AULA DE HOJE: AGRUPAMENTO DE DADOS (FUNÇÕES + CLÁUSULA GROUP BY) + LANÇAMENTO DA AC03
-- NECESSIDADE: SUMARIZAÇÃO DE VALORES E CONJUNTOS
USE PEDIDOS

SELECT * FROM TB_EMPREGADO

-- IDENTIFICAR A CONFIGURAÇÃO DA TABELA
-- SP_HELP <NOME_TABELA>
SP_HELP TB_EMPREGADO

-- FUNÇÕES DE AGRUPAMENTO E SUMARIZAÇÃO
-- OBS.: TODAS AS FUNÇÕES DE AGRUPAMENTO DESCONSIDERAM EM SEU CÁLCULO, OS VALORES NULOS

-- EXEMPLO: INFORMAR O TOTAL DE SALÁRIO GASTO PELA EMPRESA
-- SUM(CAMPO): SOMA O CONJUNTO APRESENTADO COMO PARÂMETRO DE ENTRADA, DESPREZANDO OS VALORES NULOS
SELECT	SUM(SALARIO)	AS TOTAL_SAL
FROM	TB_EMPREGADO

-- COUNT(CAMPO): CONTA AS LINHAS DE UM DETERMINADO CAMPO, DESCONSIDERANDO AS LINHAS QUE APARECEREM EM NULO
--			     E RETORNA OS DADOS EM UMA VARIÁVEL DO TIPO INT (2.147.483.647: TAMANHO MÁXIMO DE UMA TABELA)
SELECT	COUNT(SALARIO)			AS TOTAL_LINHAS_SALARIO
FROM	TB_EMPREGADO					-- QTDE: 59 LINHAS

SELECT	COUNT(CODFUN)			AS TOTAL_LINHAS_CODFUN
FROM	TB_EMPREGADO					-- QTDE: 63 LINHAS

SELECT	COUNT(SINDICALIZADO)	AS TOTAL_LINHAS_SINDICALIZADO
FROM	TB_EMPREGADO					-- QTDE: 57 LINHAS

-- COUNT(*): RETORNA A QUANTIDADE DE LINHAS DA TABELA
SELECT	COUNT(*)				AS TOTAL_LINHAS_TABELA
FROM	TB_EMPREGADO					-- QTDE: 63 LINHAS

-- EXERCICIO:
-- 1. RETORNAR A SOMA DE PREMIO MENSAL NA TABELA DE EMPREGADOS (TB_EMPREGADO), E A SOMA DE VALOR TOTAL NA TABELA DE PEDIDOS (TB_PEDIDO)
SELECT SUM(PREMIO_MENSAL)	AS	TOTAL_PREMIO FROM TB_EMPREGADO
SELECT SUM(VLR_TOTAL)		AS	TOTAL_VALOR	 FROM TB_PEDIDO

-- 2. RETORNAR A QUANTIDADE DE LINHAS DAS TABELAS: TB_ITENSPEDIDO, TB_CLIENTE
SELECT COUNT(*)				AS	QTDE_LINHAS	 FROM TB_ITENSPEDIDO
SELECT * FROM TB_ITENSPEDIDO

SELECT COUNT(CODCLI)		AS	QTDE_LINHAS  FROM TB_CLIENTE
SELECT *  FROM TB_CLIENTE

-- EXEMPLO: CALCULAR A MÉDIA DE SALARIOS DA EMPRESA
-- EU JÁ SEI CALCULAR A SOMA E JÁ SEI CALCULAR A QUANTIDADE -> MÉDIA: SOMA / QUANTIDADE
SELECT		SUM(SALARIO)				AS	TOTAL_SAL,
			COUNT(*)					AS	TOTAL_LINHAS,
			SUM(SALARIO) / COUNT(*)		AS	MEDIA_SALARIAL	-- 2181.269841
FROM		TB_EMPREGADO

SELECT		SUM(SALARIO)					AS	TOTAL_SAL,
			COUNT(*)						AS	TOTAL_LINHAS,
			SUM(SALARIO) / COUNT(SALARIO)	AS	MEDIA_SALARIAL	-- 2329.152542
FROM		TB_EMPREGADO

-- AVG(CAMPO): OPERADOR DE CÁLCULO DA MÉDIA, DESPREZA OS VALORES NULOS NO CÁLCULO
SELECT		SUM(SALARIO)				AS	TOTAL_SAL,
			COUNT(*)					AS	TOTAL_LINHAS,
			AVG(SALARIO) 				AS	MEDIA_SALARIAL	-- 2329.152542
FROM		TB_EMPREGADO

-- MIN(CAMPO): RETORNO O MENOR VALOR DE UM CONJUNTO OU CAMPO, DESPREZANDO OS NULOS
-- MAX(CAMPO): RETORNO O MAIOR VALOR DE UM CONJUNTO OU CAMPO, DESPREZANDO OS NULOS

SELECT MIN(SALARIO)	AS	MENOR_SALARIO_EMPRESA FROM TB_EMPREGADO -- 500,00
SELECT MAX(SALARIO)	AS	MAIOR_SALARIO_EMPRESA FROM TB_EMPREGADO -- 8300,00

-- OU, TRAZENDO JUNTOS...
SELECT MIN(SALARIO)	AS	MENOR_SALARIO_EMPRESA, MAX(SALARIO)	AS	MAIOR_SALARIO_EMPRESA FROM TB_EMPREGADO

-- EXERCICIO:
-- 1. RETORNAR A MEDIA DE VALOR TOTAL DA TABELA DE PEDIDO
SELECT AVG(VLR_TOTAL) AS MEDIA_VALOR FROM TB_PEDIDO

-- 2. RETORNAR A DATA DE ANIVERSÁRIO DO FUNCIONÁRIO MAIS VELHO DA EMPRESA
SELECT MIN(DATA_NASCIMENTO) AS DT_NASC_MAIS_VELHO FROM TB_EMPREGADO

-- 3. RETORNAR A DATA DE CONTRATAÇÃO DO FUNCIONÁRIO MAIS RECENTEMENTE CONTRATADO
SELECT MAX(DATA_ADMISSAO) AS FUNCIONARIO_MAIS_NOVO_DE_EMPRESA FROM TB_EMPREGADO

SELECT * FROM TB_EMPREGADO
ORDER BY DATA_NASCIMENTO

SELECT * FROM TB_EMPREGADO
ORDER BY DATA_ADMISSAO DESC

-- OBS.: RETORNAR OS NOMES DOS FUNCIONÁRIOS TAMBÉM, EU PRECISARIA FAZER COM CONSULTA APARTADA OU COM SUB CONSULTA

-- SUM(CAMPO)
-- COUNT(CAMPO) OU COUNT(*)
-- COUNT_BIG(CAMPO) OU COUNT_BIG(*)
-- AVG(CAMPO)
-- MIN(CAMPO)
-- MAX(CAMPO)

-- COUNT_BIG(CAMPO): CONTA AS LINHAS DE UM DETERMINADO CAMPO, DESCONSIDERANDO AS LINHAS QUE APARECEREM EM NULO
--					 E RETORNA OS DADOS EM UMA VARIÁVEL DO TIPO BIGINT (9.000.000.000.000.000.000: TAMANHO MÁXIMO DA TABELA)
SELECT COUNT_BIG(SALARIO)	FROM TB_EMPREGADO
SELECT COUNT(SALARIO)		FROM TB_EMPREGADO

-- PERGUNTA: UTILIZAÇÃO COM O COMANDO TOP 10
SELECT TOP 10 SUM(SALARIO) FROM TB_EMPREGADO

SELECT SUM(SALARIO) FROM
( SELECT TOP 10 SALARIO FROM TB_EMPREGADO ) AS TAB_OBJETO

-- GROUP BY: AGRUPA OS DADOS DE UMA SUMARIZAÇÃO DE ACORDO COM O(S) CRITÉRIO(S) ESCOLHIDO(S)
-- NECESSIDADE: SABER A SOMA DE SALARIOS, POR DEPARTAMENTO
SELECT		SUM(SALARIO)	AS	TOTAL_SAL,
			COD_DEPTO
FROM		TB_EMPREGADO
GROUP BY	COD_DEPTO

-- EXERCICIO:
-- 1. DETERMINAR A MEDIA DE PREMIO MENSAL POR CARGO
SELECT		AVG(PREMIO_MENSAL)	AS	MEDIA_PREMIO, 
			COD_CARGO
FROM		TB_EMPREGADO
GROUP BY	COD_CARGO

-- 2. RETORNAR A SOMA DE VENDAS POR CODIGO DO VENDEDOR (OU SEJA, QUAL VENDEDOR MAIS VENDEU?)
SELECT		SUM(VLR_TOTAL)		AS	TOTAL_VENDAS,
			CODVEN
FROM		TB_PEDIDO
GROUP BY	CODVEN
ORDER BY	TOTAL_VENDAS DESC

-- EXEMPLO: RETORNAR O TOTAL DE SALARIOS E A MÉDIA DE PREMIO MENSAL, POR DEPARTAMENTO E POR CONDIÇÃO SINDICAL
-- ESTE EXEMPLO, SERVE PARA VERIFICAR QUE É POSSÍVEL AGRUPAR POR "N" CAMPOS, ASSIM COMO É POSSÍVEL INSERIR "N" CAMPOS SUMARIZADOS
SELECT		SUM(SALARIO)		AS	TOTAL_SALARIO,
			AVG(PREMIO_MENSAL)	AS	MEDIA_PREMIO,
			COD_DEPTO,
			SINDICALIZADO
FROM		TB_EMPREGADO
GROUP BY	COD_DEPTO,
			SINDICALIZADO
ORDER BY	COD_DEPTO

-- CLÁUSULA HAVING: PERMITE FAZER FILTRO, UTILIZANDO FUNÇÕES DE AGRUPAMENTO (O QUE NÃO É PERMITIDO NO WHERE)
-- EXEMPLO: RETORNAR A SOMA DE SALARIOS POR CARGO, APENAS PARA OS CARGOS ONDE A SOMA FOR MAIOR DO QUE 5000
SELECT		SUM(SALARIO)		AS	TOTAL_SALARIO,
			COD_CARGO
FROM		TB_EMPREGADO
GROUP BY	COD_CARGO
HAVING		SUM(SALARIO) > 5000

-- EXERCICIO: 
-- 1. SELECIONAR A MEDIA DE VENDAS POR VENDEDOR, APENAS AOS QUE VENDERAM MAIS DO QUE R$ 3.000,00 DE MÉDIA
SELECT		AVG(VLR_TOTAL)		AS	MEDIA_VENDAS,
			CODVEN
FROM		TB_PEDIDO
GROUP BY	CODVEN
HAVING		AVG(VLR_TOTAL)	> 3000
ORDER BY	MEDIA_VENDAS DESC

-- DICA PARA AC03: 
-- YEAR(CAMPO DE DATA): RETORNA APENAS A PARTE DO ANO DE UMA DETERMINADA DATA
SELECT		NOME, DATA_NASCIMENTO, YEAR(DATA_NASCIMENTO) AS ANO
FROM		TB_EMPREGADO

-- CONSULTAS COM MAIS DE UMA TABELA (JOINS)
USE PEDIDOS
-- EXEMPLO OU NECESSIDADE: BUSCAR A DESCRICAO DOS CARGOS DE TODOS OS FUNCIONÁRIOS
SELECT * FROM TB_EMPREGADO		-- 63 LINHAS
SELECT * FROM TB_CARGO			-- 17 LINHAS

-- BUSCA ABAIXO, GERA UM PLANO CARTESIANO (A MULTIPLICAÇÃO DE UMA TABELA PELA OUTRA)
SELECT	*
FROM	TB_EMPREGADO, TB_CARGO	-- 1.071 LINHAS
ORDER BY NOME

SELECT 63 * 17

-- PARA GERAR UMA BUSCA COM DUAS TABELAS, E RELACIONANDO OS OBJETOS, EU PRECISO UTILIZAR A CLÁUSULA WHERE
-- JOIN INTRÍNSECO OU JOIN IMPLÍCITO
-- NOME COMPLETO DE UM CAMPO: DATABASE.OWNER.TABELA.CAMPO
SELECT	NOME, SALARIO, TB_EMPREGADO.COD_CARGO, TB_CARGO.COD_CARGO, TB_CARGO.CARGO
FROM	TB_EMPREGADO, TB_CARGO
WHERE	TB_EMPREGADO.COD_CARGO = TB_CARGO.COD_CARGO

SELECT * FROM TB_EMPREGADO	
ORDER BY COD_CARGO

-- EXERCICIO: 
-- 1. SELECIONAR OS NOMES, SALÁRIOS, CÓDIGO DO DEPARTAMENTO E SUA RESPECTIVA DESCRIÇÃO DO DEPARTAMENTO PARA TODOS OS COLABORADORES
SELECT			TB_EMPREGADO.NOME,
				TB_EMPREGADO.SALARIO,
				TB_EMPREGADO.COD_DEPTO,
				TB_DEPARTAMENTO.COD_DEPTO,
				TB_DEPARTAMENTO.DEPTO
FROM			TB_EMPREGADO, TB_DEPARTAMENTO
WHERE			TB_EMPREGADO.COD_DEPTO = TB_DEPARTAMENTO.COD_DEPTO

-- UTILIZANDO O ALIAS PARA TABELAS: MODIFICANDO A QUERY ACIMA
-- (ANTES) ALIAS: NOVO NOME PARA UMA COLUNA JÁ EXISTENTE OU NOME PARA UMA COLUNA NOVA
-- ADICIONANDO DEFINIÇÃO: 
-- (AGORA) ALIAS: NOVO NOME PARA UM OBJETO JÁ EXISTENTE OU NOME PARA UMA OBJETO NOVO (EX.: TABELA)
SELECT			EMP.NOME,
				EMP.SALARIO,
				EMP.COD_DEPTO,
				DEP.COD_DEPTO,
				DEP.DEPTO

FROM			TB_EMPREGADO			AS	EMP, 
				TB_DEPARTAMENTO			AS	DEP

WHERE			EMP.COD_DEPTO			=	DEP.COD_DEPTO

-- EXERCICIO: 
-- 1. (USANDO O ALIAS) RETORNAR OS NOMES DOS DEPENDENTES ASSOCIADOS A CADA FUNCIONÁRIO, TRAZER TB A COLUNA NUM_DEPEND
SELECT		EMP.NOME		AS	NOME_FUNC,
			DEP.NOME		AS	NOME_DEPN,	
			EMP.NUM_DEPEND
FROM		TB_EMPREGADO		AS	EMP,
			TB_DEPENDENTE		AS	DEP
WHERE		EMP.CODFUN			=	DEP.CODFUN
-- 2. (AUMENTANDO A COMPLEXIDADE) RETORNAR A DIFERENÇA ENTRE O SALARIO ATUAL E O SALARIO INICIAL DE TODOS OS COLABORADORES SINDICALIZADOS
SELECT			EMP.NOME,
				EMP.SALARIO,
				CRG.SALARIO_INIC,
				EMP.SALARIO - CRG.SALARIO_INIC AS DIFERENCA_SALARIAL,
				EMP.SINDICALIZADO
FROM			TB_EMPREGADO	AS	EMP,
				TB_CARGO		AS	CRG
WHERE			EMP.COD_CARGO	=	CRG.COD_CARGO
  AND			EMP.SINDICALIZADO = 'S'

SELECT TOP 1 * FROM TB_EMPREGADO
SELECT TOP 1 * FROM TB_CARGO

-- SELECTS ENVOLVENDO "N" TABELAS...
-- EXEMPLO: SELECIONAR OS NOMES, DESCRICAO DE DEPARTAMENTO E DE CARGO DE TODOS OS FUNCIONÁRIOS
SELECT		*


FROM		TB_EMPREGADO	AS	EMP,
			TB_DEPARTAMENTO	AS	DEP,
			TB_CARGO		AS	CRG

WHERE		EMP.COD_DEPTO	=	DEP.COD_DEPTO
  AND		EMP.COD_CARGO	=	CRG.COD_CARGO

-- EXERCICIO:
-- 1. LISTAR A DESCRICAO DO PRODUTO, A DATA DE EMISSÃO DOS PEDIDOS E A DATA DE ENTREGA DOS PEDIDOS (GRAU DE COMPLEXIDADE: DIFÍCIL)
SELECT		PRD.DESCRICAO,
			PED.DATA_EMISSAO,
			ITN.DATA_ENTREGA
FROM		TB_PRODUTO		AS	PRD,
			TB_PEDIDO		AS	PED,
			TB_ITENSPEDIDO	AS	ITN
WHERE		PRD.ID_PRODUTO	=	ITN.ID_PRODUTO
 AND		PED.NUM_PEDIDO	=	ITN.NUM_PEDIDO

-- FUNÇÃO DE QUEBRA DE UM CAMPO EM FORMATO DATA: 
-- YEAR(CAMPO DE DATA):		RETORNA APENAS A PARTE DO ANO DE UMA DETERMINADA DATA
-- MONTH(CAMPO DE DATA):	RETORNA APENAS A PARTE DO MÊS DE UMA DETERMINADA DATA
-- DAY(CAMPO DE DATA):		RETORNA APENAS A PARTE DO DIA DE UMA DETERMINADA DATA
SELECT		NOME, DATA_NASCIMENTO, 
			YEAR(DATA_NASCIMENTO) AS ANO,
			MONTH(DATA_NASCIMENTO) AS MES,
			DAY(DATA_NASCIMENTO) AS DIA
FROM		TB_EMPREGADO

-- JOIN EXPLÍCITO: CONSULTAS ENVOLVENDO "N" TABELAS + CLÁUSULA JOIN E SUAS VARIAÇÕES

-- EXEMPLO: SELECIONAR OS NOMES, SALÁRIOS, CÓDIGO DO DEPARTAMENTO E SUA RESPECTIVA DESCRIÇÃO DO DEPARTAMENTO PARA TODOS OS COLABORADORES
SELECT			EMP.NOME,
				EMP.SALARIO,
				EMP.COD_DEPTO,
				DEP.COD_DEPTO,
				DEP.DEPTO

FROM			TB_EMPREGADO		AS	EMP

INNER JOIN		TB_DEPARTAMENTO		AS	DEP
ON				EMP.COD_DEPTO		= DEP.COD_DEPTO

-- EXERCICIO: (UTILIZADO O INNER JOIN)
-- 1. SELECIONAR OS NOMES DOS EMPREGADOS E DE SEUS DEPENDENTES. APENAS PARA FUNCIONÁRIOS COM SALARIO SUPERIOR A 2000.
SELECT			EMP.NOME			AS	NOME_FUNCIONARIO,
				DEP.NOME			AS	NOME_DEPENDENTE,
				EMP.SALARIO
FROM			TB_EMPREGADO		AS	EMP

INNER JOIN		TB_DEPENDENTE		AS	DEP
ON				EMP.CODFUN			=	DEP.CODFUN

WHERE			SALARIO				>	2000

-- 2. TRANFORMAR A QUERY ABAIXO, PARA UTILIZAÇÃO DE INNER JOINS 
SELECT		PRD.DESCRICAO,
			PED.DATA_EMISSAO,
			ITN.DATA_ENTREGA

FROM		TB_ITENSPEDIDO	AS	ITN

INNER JOIN	TB_PEDIDO		AS	PED
ON			PED.NUM_PEDIDO	=	ITN.NUM_PEDIDO

INNER JOIN	TB_PRODUTO		AS	PRD
ON			PRD.ID_PRODUTO	=	ITN.ID_PRODUTO

USE PEDIDOS

-- JOINS (CONTINUAÇÃO...)
SELECT * FROM TB_EMPREGADO			-- 64 LINHAS
SELECT * FROM TB_DEPENDENTE			-- 51 LINHAS

SELECT		* -- DISTINCT EMP.NOME
FROM		TB_EMPREGADO	AS	EMP
INNER JOIN	TB_DEPENDENTE	AS	DEP
ON			EMP.CODFUN		=	DEP.CODFUN
-- 20 EMPREGADOS QUE POSSUEM DEPENDENTES. ONDE ESTÃO OS DEMAIS (44)?

-- LEFT JOIN: SELECIONA TODOS OS REGISTROS DA TABELA "A" (A ESQUERDA), POSSUINDO OU NÃO RELACIONAMENTO COM A TABELA "B"
SELECT		*
FROM		TB_EMPREGADO	AS	EMP
LEFT JOIN	TB_DEPENDENTE	AS	DEP
ON			EMP.CODFUN		=	DEP.CODFUN

SELECT * FROM TB_DEPENDENTE ORDER BY CODFUN

-- EXERICICIO:
-- 1. SELECIONAR TODOS OS FUNCIONÁRIOS, COM SEUS RESPECTIVOS CARGOS			(UTILIZANDO LEFT JOIN)
SELECT		*
FROM		TB_EMPREGADO	AS	EMP
LEFT JOIN	TB_CARGO		AS	CAR
ON			EMP.COD_CARGO	=	CAR.COD_CARGO
-- INNER JOIN: 58 LINHAS
-- LEFT JOIN: 64 LINHAS

SELECT		*
FROM		TB_CARGO		AS	CAR
LEFT JOIN	TB_EMPREGADO	AS	EMP
ON			EMP.COD_CARGO	=	CAR.COD_CARGO


-- 2. SELECIONAR TODOS OS FUNCIONÁRIOS, COM SEUS RESPECTIVOS DEPARTAMENTOS	(UTILIZANDO LEFT JOIN)
SELECT		*
FROM		TB_EMPREGADO	AS	EMP
LEFT JOIN	TB_DEPARTAMENTO	AS	DPT
ON			EMP.COD_DEPTO	=	DPT.COD_DEPTO

SELECT		*
FROM		TB_DEPARTAMENTO	AS	DPT
LEFT JOIN	TB_EMPREGADO	AS	EMP
ON			EMP.COD_DEPTO	=	DPT.COD_DEPTO

-- UTILIZANDO O RIGHT JOIN: SELECIONA TODOS OS REGISTROS DA TABELA "B" (A DIREITA), POSSUINDO OU NÃO RELACIONAMENTO COM A TABELA "A"
SELECT		DPT.*, EMP.*
FROM		TB_EMPREGADO	AS	EMP
RIGHT JOIN	TB_DEPARTAMENTO	AS	DPT
ON			EMP.COD_DEPTO	=	DPT.COD_DEPTO

-- TESTE DE QUEBRA DE CHAVE

/*
SELECT	[ ALL | DISTINCT ]									-- OK
		[TOP ( expression ) [PERCENT] [ WITH TIES ] ]		-- OK
		< select_list >										-- OK
[ INTO new_table ]											-- JUNTO COM INSERT (DEPOIS...)
[ FROM { <table_source> } [ ,...n ] ]						-- OK
*/

SELECT		*
INTO		TB_EMPREGADO_BKP
FROM		TB_EMPREGADO

SELECT		*
INTO		TB_DEPENDENTE_BKP
FROM		TB_DEPENDENTE

SELECT * FROM TB_EMPREGADO_BKP
SELECT * FROM TB_DEPENDENTE_BKP

-- EXERCICIO:
-- 1. CADASTRAR FUNCIONÁRIOS NOVOS E NÃO INSERIR DEPENDENTES PARA ELES
INSERT TB_EMPREGADO_BKP
( NOME )
VALUES
( 'FABIANO' ),
( 'CICERO' ),
( 'BRUNO' ),
( 'MARCO' ),
( 'JOSÉ ABEL' )

-- 2. CADASTRAR DEPENDENTES NOVOS E NÃO INSERIR FUNCIONÁRIOS PARA ELES
INSERT TB_DEPENDENTE_BKP
( NOME , CODFUN , CODDEP )
VALUES
( 'ISABELLA' , 12000 , 1 ),
( 'GIOVANNA' , 12001 , 1 ),
( 'YONE' , 12002 , 1 ),
( 'EMILLY' , 12003 , 1 ),
( 'DAIANE' , 12004 , 1 )

-- 3. REALIZAR AS CONSULTAS UTILIZANDO LEFT E RIGHT JOIN [SEMPRE DEIXANDO A EMPREGADO ANTES (OU A ESQUERDA) E A DEPENDENTE DEPOIS]
SELECT			*
FROM			TB_EMPREGADO_BKP	AS	EMP
LEFT JOIN		TB_DEPENDENTE_BKP	AS	DEP
ON				EMP.CODFUN		=	DEP.CODFUN

SELECT			*
FROM			TB_EMPREGADO_BKP	AS	EMP
RIGHT JOIN		TB_DEPENDENTE_BKP	AS	DEP
ON				EMP.CODFUN		=	DEP.CODFUN

-- 4. DISCUTIR O QUE OBSERVAMOS...
-- LEMBRETES...
-- LEFT JOIN: A TABELA A É A DOMINANTE. ELA QUE IDENTIFICA OU DESCARTA OS RELACIONAMENTOS
-- RIGHT JOIN: A TABELA B É A DOMINANTE. ELA QUE IDENTIFICA OU DESCARTA OS RELACIONAMENTOS

-- LEFT E RIGHT JOIN COM TRATAMENTO DE NULOS
-- EXEMPLO: RETORNAR APENAS OS EMPREGADOS QUE NÃO POSSUAM DEPENDENTES
SELECT		*
FROM		TB_EMPREGADO_BKP	AS	EMP
LEFT JOIN	TB_DEPENDENTE_BKP	AS	DEP
ON			EMP.CODFUN			=	DEP.CODFUN
WHERE		DEP.CODFUN			IS	NULL

-- EXEMPLO: RETORNAR APENAS OS DEPENDENTES QUE NÃO POSSUAM EMPREGADOS ATRELADOS
SELECT		*
FROM		TB_EMPREGADO_BKP	AS	EMP
RIGHT JOIN	TB_DEPENDENTE_BKP	AS	DEP
ON			EMP.CODFUN			=	DEP.CODFUN
WHERE		EMP.CODFUN			IS	NULL

-- OU, FAZENDO COM LEFT MAS TROCANDO A ORDEM DAS TABELAS
SELECT		*
FROM		TB_DEPENDENTE_BKP	AS	DEP
LEFT JOIN	TB_EMPREGADO_BKP	AS	EMP
ON			EMP.CODFUN			=	DEP.CODFUN
WHERE		EMP.CODFUN			IS	NULL

-- EXERCICIO:
-- 1. SELECIONAR TODOS OS PEDIDOS COM SEUS RESPECTIVOS ITENS DE PEDIDO
SELECT		*
FROM		TB_PEDIDO		AS	PED
INNER JOIN	TB_ITENSPEDIDO	AS	ITN
ON			PED.NUM_PEDIDO	=	ITN.NUM_PEDIDO

-- 2. QUERO SABER SE EXISTEM PEDIDOS QUE NÃO POSSUEM ITENS ATRELADOS 
SELECT		*
FROM		TB_PEDIDO		AS	PED
LEFT JOIN	TB_ITENSPEDIDO	AS	ITN
ON			PED.NUM_PEDIDO	=	ITN.NUM_PEDIDO
WHERE		ITN.NUM_PEDIDO	IS	NULL

SELECT * FROM TB_ITENSPEDIDO WHERE NUM_PEDIDO IN ( 1 , 25 , 26 , 27 )

-- 3. QUERO SABER SE EXISTEM ITENS DE PEDIDOS QUE NÃO POSSUEM PEDIDOS ATRELADOS 
SELECT		*
FROM		TB_PEDIDO		AS	PED
RIGHT JOIN	TB_ITENSPEDIDO	AS	ITN
ON			PED.NUM_PEDIDO	=	ITN.NUM_PEDIDO
WHERE		PED.NUM_PEDIDO	IS	NULL

-- OBSERVAÇÃO: QUANDO UMA DAS LATERALIDADES (RIGHT OU LEFT) ENCONTRA QUANTIDADE DE REGISTROS IGUAL A DO INNER JOIN, EU TENHO UM
--			   INDICATIVO DE QUE A ESTRUTURA DE PRIMARY E FOREIGN KEY GARANTIU A INTEGRIDADE

-- FULL OUTER JOIN (COM E SEM TRATAMENTO DE NULOS): RETORNA TUDO DAS DUAS TABELAS, POSSUINDO OU NÃO RELACIONAMENTO (TRAT. NULOS)
-- UTILIZAÇÃO PRÁTICA: QUANDO EU PRECISO UNIFICAR DUAS TABELAS, INDEPENDENTEMENTE DA RELAÇÃO
SELECT				*
FROM				TB_DEPENDENTE_BKP	AS	DEP
FULL OUTER JOIN		TB_EMPREGADO_BKP	AS	EMP
ON					EMP.CODFUN			=	DEP.CODFUN


-- UTILIZAÇÃO PRÁTICA: SANEAMENTO DE BASES --> QUANDO PRECISAMOS IDENTIFICAR GAPS EM NOSSA RELAÇÃO DE CHAVES OU RELACIONAMENTOS
SELECT				*
FROM				TB_DEPENDENTE_BKP	AS	DEP
FULL OUTER JOIN		TB_EMPREGADO_BKP	AS	EMP
ON					EMP.CODFUN			=	DEP.CODFUN
WHERE				EMP.CODFUN			IS	NULL
  OR				DEP.CODFUN			IS	NULL


-- EXERCICIOS DE PRESENÇA
-- 1. LISTAR OS NOMES DOS PRODUTOS, SEU PRECO DE CUSTO, SEUS ITENS DE PEDIDO RELACIONADOS E A DIFERENÇA ENTRE O PRECO DE CUSTO E O PRECO UNITARIO (INNER JOIN)
SELECT TOP 1 * FROM TB_PRODUTO
SELECT TOP 1 * FROM TB_ITENSPEDIDO

-- 2. LISTAR TODOS OS EMPREGADOS COM OS NOMES DE SEUS CARGOS E A DIFERENCA ENTRE O SALARIO INICIAL E O PREMIO MENSAL (LEFT JOIN)
SELECT TOP 1 * FROM TB_EMPREGADO
SELECT TOP 1 * FROM TB_CARGO

-- 3. LISTAR OS PRODUTOS, RELACIONANDO COM OS SEUS TIPOS. TRAZER APENAS TIPOS DE PRODUTOS QUE INICIEM COM VOGAIS (RIGHT JOIN)
SELECT TOP 1 * FROM TB_PRODUTO
SELECT TOP 1 * FROM TB_TIPOPRODUTO

-- 4. ENCONTRAR OS FORNECEDORES E OS RESPECTIVOS PRODUTOS ATRELADOS A CADA UM DELES (JOIN A SUA ESCOLHA)
SELECT TOP 1 * FROM TB_FORNECEDOR
SELECT TOP 1 * FROM TB_PROD_FORN
SELECT TOP 1 * FROM TB_PRODUTO

-- 5. ESCOLHER DUAS TABELAS QUE SE RELACIONEM E REALIZAR O FULL OUTER JOIN COM E SEM O TRATAMENTO DE NULOS (QUALQUER TABELA DO BANCO PEDIDOS)

USE PEDIDOS

-- FUNÇÕES DE TRATAMENTO DE TEXTO
-- DESAFIO: ALTERAÇÃO DOS SOBRENOMES EM UM TEXTO (+1 PONTO NA NOTA FINAL)

SELECT		*
FROM		TB_EMPREGADO	AS	EMP
LEFT JOIN	TB_DEPENDENTE	AS	DEP
ON			EMP.CODFUN		=	DEP.CODFUN

-- FUNÇÕES DE TRATAMENTO DE NULOS
-- COALESCE(CAMPO, 'NOVO VALOR'): SUBSTITUI O VALOR NULL POSSIVELMENTE ENCONTRADO NO CAMPO UTILIZADO COMO PARÂMETRO, PELO TEXTO DIGITADO
--								  CRIA UM CAMPO NOVO (VIRTUAL) COM O TAMANHO DO TEXTO QUE VOCÊ ENVIOU
SELECT		TOP 3
			EMP.NOME	AS	NOME_FUNC,
			DEP.NOME	AS	NOME_DEPN,	
			COALESCE(DEP.NOME, 'NÃO ENCONTRADO DEPENDENTE PARA ESTE FUNCIONÁRIO')	AS	NOME_DEPN_TRATADO
FROM		TB_EMPREGADO	AS	EMP
LEFT JOIN	TB_DEPENDENTE	AS	DEP
ON			EMP.CODFUN		=	DEP.CODFUN
WHERE		DEP.NOME IS NULL

-- ISNULL(CAMPO, 'NOVO VALOR'): SUBSTITUI O VALOR NULL POSSIVELMENTE ENCONTRADO NO CAMPO UTILIADO COMO PARÂMETRO, PELO TEXTO DIGITADO
--								RESPEITA O TAMANHO DO CAMPO ORIGINALMENTE TRATADO
SELECT		TOP 3
			EMP.NOME	AS	NOME_FUNC,
			DEP.NOME	AS	NOME_DEPN,	
			ISNULL(DEP.NOME, 'NÃO ENCONTRADO DEPENDENTE PARA ESTE FUNCIONÁRIO')	AS	NOME_DEPN_TRATADO
FROM		TB_EMPREGADO	AS	EMP
LEFT JOIN	TB_DEPENDENTE	AS	DEP
ON			EMP.CODFUN		=	DEP.CODFUN
WHERE		DEP.NOME IS NULL

-- EXERCICIO:
-- 1. SUBSTITUIR OS NULOS ENCONTRADOS NO CAMPO SINDICALIZADO DA TABELA TB_EMPREGADO POR UMA INFORMAÇÃO MAIS AMIGÁVEL (COALESCE)
SELECT	SINDICALIZADO,
		COALESCE(SINDICALIZADO, 'FUNCIONÁRIO SEM A INFORMAÇÃO DE CONDIÇÃO SINDICAL') AS SINDICALIZADO_TRATADO
FROM	TB_EMPREGADO

-- UTILIZANDO ISNULL FICARIA INCOMPLETO POIS SÓ TEM UM BYTE A TRATAR A INFORMAÇÃO
SELECT	SINDICALIZADO,
		ISNULL(SINDICALIZADO, 'FUNCIONÁRIO SEM A INFORMAÇÃO DE CONDIÇÃO SINDICAL') AS SINDICALIZADO_TRATADO
FROM	TB_EMPREGADO

-- 2. SUBSTITUIR OS NULOS ENCONTRADOS NO CAMPO BAIRRO DA TABELA TB_CLIENTE POR UMA INFORMAÇÃO MAIS AMIGÁVEL (ISNULL)
SELECT		BAIRRO,
			ISNULL(BAIRRO, 'BAIRRO Ñ CADASTRADO') AS BAIRRO_TRATADO
FROM		TB_CLIENTE

-- TRATANDO E COMPARANDO DATAS
SELECT GETDATE()

-- ELE CONFIGURA UMA LEITURA EM DIA, MÊS E ANO PARA QUANDO INSERIDO
SET DATEFORMAT DMY

--Valor		Ordem
--mdy			Mês, dia e ano (Formato padrão americano).
--dmy			Dia, mês e ano.
--ymd			Ano, mês e dia.
--ydm			Ano, dia e mês.
--myd			Mês, ano e dia.
--dym			Dia, ano e mês.

-- SOMANDO DIAS EM UMA DATA: EU APENAS UTILIZO O OPERADOR + ACRESCIDO DO NUMERO DE DIAS QUE VOCÊ DESEJA CALCULAR
SELECT GETDATE() + 7

-- CAST(CAMPO AS NOVO_FORMATO): TRANSFORMANDO UM CAMPO DE UM FORMATO "X" PARA UM FORMATO "Y": 

-- EXEMPLO: ALTERANDO UM CAMPO DE DATA PARA INTEIRO
-- DETERMINAR A QUANTIDADE DE DIAS PASSADOS DESDE A CONTRATACAO DE UM FUNCIONÁRIO ATÉ A DATA DE HOJE
SELECT		NOME,
			DATA_ADMISSAO,
			GETDATE() - DATA_ADMISSAO,
			CAST(GETDATE() AS INT) - CAST(DATA_ADMISSAO AS INT)
FROM		TB_EMPREGADO

-- EXERCICIO:
-- 1. DETERMINAR QUANTOS ANOS EU TENHO CALCULADOS ENTRE A DATA DE ADMISSAO DE UM FUNCIONÁRIO E A DATA ATUAL
SELECT		NOME,
			DATA_ADMISSAO,
			GETDATE() AS DATA_ATUAL,
			(CAST(GETDATE() AS REAL) - CAST(DATA_ADMISSAO AS REAL)) / 360
FROM		TB_EMPREGADO
ORDER BY	DATA_ADMISSAO

-- 2. DETERMINAR QUANTOS MESES EU TENHO CALCULADOS ENTRE A DATA DE ADMISSAO DE UM FUNCIONÁRIO E A DATA ATUAL
SELECT		NOME,
			DATA_ADMISSAO,
			GETDATE() AS DATA_ATUAL,
			(CAST(GETDATE() AS REAL) - CAST(DATA_ADMISSAO AS REAL)) / 30
FROM		TB_EMPREGADO
ORDER BY	DATA_ADMISSAO

-- TRANSFORMANDO CAMPOS NUMÉRICOS EM ALFANUMÉRICOS
SELECT	NOME,
		COD_CARGO,
		COALESCE(COD_CARGO, 9999) AS COD_CARGO_TRATADO
FROM	TB_EMPREGADO

SELECT	NOME,
		COD_CARGO,
		CAST(COD_CARGO AS VARCHAR(10)) AS COD_CARGO_ALFA,
		COALESCE(CAST(COD_CARGO AS VARCHAR(10)),'NÃO ENCONTRADO CARGO') AS COD_CARGO_ALFA_TRATADO
FROM	TB_EMPREGADO

-- LEFT (CAMPO, QTD_REG): RETORNA OS "N" REGISTROS A ESQUERDA DE UM CAMPO TEXTO
-- RIGHT(CAMPO, QTD_REG): RETORNA OS "N" REGISTROS A DIREITA DE UM CAMPO TEXTO
SELECT			NOME,
				LEFT(NOME, 10) AS DEZ_A_ESQUERDA
FROM			TB_CLIENTE

SELECT			NOME,
				RIGHT(NOME, 10) AS DEZ_A_DIREITA
FROM			TB_CLIENTE

-- SUBSTRING(CAMPO, POS_INI, QTD_REG): CAPTURAR "N" REGISTROS DO MEIO DE UM DETERMINADO CAMPO
SELECT			NOME,
				SUBSTRING(NOME, 5, 5) AS POS_5_A_9
FROM			TB_CLIENTE

-- LEN(CAMPO): RETORNA A QUANTIDADE DE BYTES DE UM DETERMINADO CAMPO
SELECT CNPJ, LEN(CNPJ) AS TAM_CAMPO FROM TB_CLIENTE

-- CONCAT(CAMPO1, CAMPO2, CAMPO3, ..., CAMPON): CONCATENA A INFORMAÇÃO DE UM CAMPO COM OUTRO
SELECT		CONCAT(NOME, ' - IMPACTA' ) AS NOVO_NOME FROM TB_EMPREGADO

SELECT	CNPJ, LEN(CNPJ) AS TAM_CAMPO, CONCAT(CNPJ, '/0001-40') FROM	TB_CLIENTE

-- EXERCICIO:
-- 1. TRATAR O CAMPO CNPJ DA TABELA DE CLIENTES, PARA RETORNAR NO FORMATO DE UM CNPJ NN.NNN.NNN/NNNN-NN
SELECT		CNPJ,
			LEFT(CNPJ, 2)			AS	PRIM_PECA,	-- NN
			SUBSTRING(CNPJ, 3, 3)	AS	SGND_PECA,	-- NNN
			SUBSTRING(CNPJ, 6, 3)	AS	TRCR_PECA,	-- NNN
			SUBSTRING(CNPJ, 9, 4)	AS	QURT_PECA,	-- NNNN
			RIGHT(CNPJ, 2)			AS	QUNT_PECA,	-- NN
			CONCAT	(	
						LEFT(CNPJ, 2)			,
						'.'						,
						SUBSTRING(CNPJ, 3, 3)	,
						'.'						,
						SUBSTRING(CNPJ, 6, 3)	,
						'/'						,
						SUBSTRING(CNPJ, 9, 4)	,
						'-'						,
						RIGHT(CNPJ, 2)
					)				AS	CNPJ_FORMATADO
FROM		TB_CLIENTE
WHERE		LEN(CNPJ) = 14

00 125 348 0001 02

-- REPLICATE(VALOR, QTD_VEZES)
SELECT REPLICATE('0', 5)

-- EXEMPLO: PREENCHER ZEROS A ESQUERDA DE UM DETERMINADO NÚMERO
-- QUANTOS ZEROS A ESQUERDA? O COMANDO LEN(CAMPO) ME AJUDA COM ESSA INFORMAÇÃO...
SELECT		CNPJ,
			LEN(CNPJ) TAM_CAMPO,
			REPLICATE('0', 14 - LEN(CNPJ)) AS ZEROS_A_ESQ,
			CONCAT	(
						REPLICATE('0', 14 - LEN(CNPJ))			,
						CNPJ
					)	AS	CNPJ_14
FROM		TB_CLIENTE
WHERE		CNPJ IS NOT NULL

-- CHARINDEX(VALOR, CAMPO): RETORNA A POSIÇÃO INICIAL DE UM DETERMINADO VALOR, QUANDO PESQUISADO UM CAMPO (CONSIDERA APENAS A PRIMEIRA OCORRÊNCIA)
-- EXEMPLO: DETERMINAR A POSIÇÃO DO ARROBA E UM EMAIL
SELECT		CHARINDEX('@', 'FABIANO.PASSOS@YMAIL.COM') AS POSICAO_ARROBA

SELECT		CHARINDEX('.BR', 'FABIANO.PASSOS@YMAIL.COM') AS POSICAO_ARROBA

-- EXERCICIO DESAFIO: VALENDO +1 PONTO NA MÉDIA FINAL (PARA ENTREGAR ATÉ 11:30H)
-- SUBSTITUIR TODOS OS "SILV" POR "RODRIGUES" NA TABELA DE EMPREGADO
SELECT			NOME
FROM			TB_EMPREGADO
WHERE			NOME LIKE '%SILV%'


-- RESOLUÇÃO:
-- 1. BUSCAR A POSIÇÃO DO "SILV" (PARA POSICIONAR O CURSOR)	-	OK
-- 2. SEPARA TUDO QUE VEM ANTES DO "SILV"					-	OK
-- 3. SEPARA TUDO QUE VEM APÓS O "SILV"						-	OK
-- 4. CONCATENA: ANTES + "RODRIGUES" + DEPOIS				-	
SELECT			NOME,
				CHARINDEX('SILV', NOME)										AS	POSICAO_INICIAL_SILV,
				LEFT( NOME , CHARINDEX('SILV', NOME) - 1 )					AS	ANTES_DO_SILV,
				SUBSTRING( NOME , CHARINDEX('SILV', NOME) + 4 , 35 )		AS	APOS_O_SILV,
				CONCAT	(
							LEFT( NOME , CHARINDEX('SILV', NOME) - 1 )	,								
							'RODRIGUES'									,	
							SUBSTRING( NOME , CHARINDEX('SILV', NOME) + 4 , 35 )  -- PODERIA SUBSTITUIR POR UM CÁLCULO QUE UTILIZASSE LEN
						)	AS	NOME_ALTERADO
FROM			TB_EMPREGADO
WHERE			NOME LIKE '%SILV%'

123456789012345678901234567890
CARLOS ALBERTO SILVA NASLMALMSAS AKSÇAMÇSAÇSLMÇA ÇOKASÇLKSÇLAKSA                                        
JOAO LIMA MACHADO DA SILVA

-- DICAS: ENCONTRAR O SILV, SEPARAR TUDO QUE VEM ANTES, TUDO QUE VEM DEPOIS... E JUNTAR AS PEÇAS NA CONCATENAÇÃO!
SELECT			REPLACE(NOME, 'SILV', 'RODRIGUES') AS NOME_ALTERADO,
				NOME AS NOME_ORIGINAL
FROM			TB_EMPREGADO
WHERE			NOME LIKE '%SILV%'

-- CRIAR BACKUP PARA 5 DAS TABELAS DO BANCO DE DADOS PEDIDOS (PREPARAÇÃO PARA EXERCÍCIO DO DIA)
USE PEDIDOS

DROP TABLE   TB_EMPREGADO_BKP
		   , TB_CLIENTE_BKP
		   , TB_PEDIDO_BKP
		   , TB_ITENSPEDIDO_BKP
		   , TB_DEPENDENTE_BKP


SELECT	*
INTO	TB_EMPREGADO_BKP
FROM	TB_EMPREGADO

SELECT	*
INTO	TB_CLIENTE_BKP
FROM	TB_CLIENTE

SELECT	*
INTO	TB_PEDIDO_BKP
FROM	TB_PEDIDO

SELECT	*
INTO	TB_ITENSPEDIDO_BKP
FROM	TB_ITENSPEDIDO

SELECT	*
INTO	TB_DEPENDENTE_BKP
FROM	TB_DEPENDENTE

SELECT	TOP 1 * FROM TB_EMPREGADO_BKP
SELECT	TOP 1 * FROM TB_CLIENTE_BKP
SELECT	TOP 1 * FROM TB_PEDIDO_BKP
SELECT	TOP 1 * FROM TB_ITENSPEDIDO_BKP
SELECT	TOP 1 * FROM TB_DEPENDENTE_BKP

-- ATUALIZAÇÃO E DELEÇÃO DE DADOS (UPDATE + DELETE)
UPDATE tabela
SET nome_coluna = expressao [, nome_coluna = expressao,...]
 [WHERE condicao]

-- EXEMPLO: ATUALIZAR O SALÁRIO DO EMPREGADO OLAVO PARA 4000
SELECT * FROM TB_EMPREGADO_BKP
WHERE CODFUN = 1

UPDATE	TB_EMPREGADO_BKP
SET		SALARIO = 4000
WHERE	CODFUN = 1

-- EXEMPLO: ATUALIZAR O SALARIO, SOMANDO 100 REAIS NO MESMO E ATUALIZAR A CONDIÇÃO SINDICAL PARA "NÃO" OU "N"
UPDATE	TB_EMPREGADO_BKP
SET		SALARIO			= SALARIO + 100	,
		SINDICALIZADO	= 'N'
WHERE	CODFUN = 1

-- EXERCICIO:
-- 1.	ATUALIZAR O PREMIO_MENSAL DE TODOS OS COLABORADORES QUE POSSUAM CODIGO DO DEPARTAMENTO MENOR DO QUE 10.
--		O NOVO VALOR DO PREMIO_MENSAL, SERÁ IGUAL A METADE DO SALÁRIO
SELECT	NOME, 
		SALARIO, 
		PREMIO_MENSAL, 
		SALARIO / 2 AS NOVO_PREMIO_MENSAL 
FROM	TB_EMPREGADO_BKP
WHERE	COD_DEPTO < 10

UPDATE	TB_EMPREGADO_BKP
SET		PREMIO_MENSAL = SALARIO / 2
WHERE	COD_DEPTO < 10

SELECT	NOME, 
		SALARIO, 
		PREMIO_MENSAL
FROM	TB_EMPREGADO_BKP
WHERE	COD_DEPTO < 10

-- EXEMPLO: ATUALIZAR O CODFUN DO OLAVO PARA 2
SELECT TOP 3 * FROM TB_EMPREGADO_BKP

UPDATE	TB_EMPREGADO_BKP
SET		CODFUN = 2
WHERE	CODFUN = 1

-- INICIANDO E FINALIZANDO TRANSAÇÕES
BEGIN TRANSACTION
BEGIN TRAN

SELECT * FROM TB_EMPREGADO_BKP WHERE CODFUN = 1

UPDATE TB_EMPREGADO_BKP
SET		SALARIO = 6000
WHERE	CODFUN = 1

--CONFIRMAR A TRANSAÇÃO
COMMIT

-- DEU ERRO! E VOU CANCELAR A TRANSAÇÃO!
ROLLBACK

SELECT @@TRANCOUNT

-- ORDEM DE EXECUÇÃO E FECHAMENTO
BEGIN TRANSACTION + COMMIT	 (ENCERRA A TRANSACTION OU O MODO tempdb ATIVO)
BEGIN TRANSACTION + ROLLBACK (ENCERRA A TRANSACTION OU O MODO tempdb ATIVO)

-- OUTPUT: ELE RETORNA O RESULTADO DE UMA ATUALIZAÇAO OU DELEÇÃO DE DADOS, COM O CONTEÚDO DA TABELA ANTES E/OU DEPOIS
-- Deleted: CONTEÚDO ANTES DA ATUALIZAÇÃO
-- Inserted: NOVO CONTEÚDO DA TABELA
UPDATE	<tabela> 
SET		<campo1> = <expr1> [,...]
[OUTPUT deleted|inserted.<nomeCampo> [,...]]
[WHERE <condição>]

BEGIN TRAN

UPDATE	TB_EMPREGADO_BKP
SET		NOME = NOME + ' IMPACTA'
OUTPUT	Inserted.NOME	,
		Deleted.NOME
WHERE	CODFUN = 1


UPDATE	TB_EMPREGADO_BKP
SET		NOME = NOME + ' IMPACTA'
OUTPUT	Inserted.NOME	AS	NOME_APOS_UPDATE,
		Deleted.NOME	AS	NOME_ANTES_UPDATE
WHERE	CODFUN = 1

SELECT * FROM TB_EMPREGADO_BKP WHERE CODFUN = 1

ROLLBACK

-- DELETE: APAGA OS REGISTROS DE UMA TABELA
DELETE [FROM] tabela
 [WHERE condicao]

-- EXEMPLO: DELETAR DA TABELA DE EMPREGADOS, O OLAVO
DELETE	TB_EMPREGADO_BKP
WHERE	CODFUN = 1

-- EXEMPLO: DELETAR TODOS OS EMPREGADOS QUE POSSUAM SALARIO MENOR DO QUE 3000 E QUE NÃO SEJAM SINDICALIZADOS
DELETE	TB_EMPREGADO_BKP
WHERE	SALARIO < 3000 AND SINDICALIZADO = 'N'

-- OUTPUT: ELE RETORNA O RESULTADO DE UMA ATUALIZAÇAO OU DELEÇÃO DE DADOS, COM O CONTEÚDO DA TABELA ANTES E/OU DEPOIS
-- Deleted: CONTEÚDO ANTES DO DELETE
-- Inserted: NO DELETE, NÃO EXISTE CONDIÇÃO, APÓS A ATUALIZAÇÃO DA TABELA (DELETE)
DELETE	<tabela> 
[OUTPUT deleted.<nomeCampo> [,...]]
[WHERE <condição>]

DELETE	TB_EMPREGADO_BKP
OUTPUT	Deleted.*
WHERE	SALARIO > 5000
